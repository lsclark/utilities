#! /usr/bin/env python3

"""Duplicate file management

Performs two functions:

FIND
----
Grabs the md5 hashes for all files in a given directory (and subdirectories) and
identifies any duplicates. Handling can be done in one of three ways:
    1. The output is logged to the console
    2. The user is prompted for which files to delete
    3. A CSV is generated that lists all duplicates (which can be updated)

DELETE
------
Deletes files marked as duplicates from the CSV generated by the FIND function.
The format of the CSV is as follows:
    `[md5],[file_keep],[file_dupe1],[file_dupe2],...`
Move the file into the keep position to keep that one and delete the others.
"""
import csv
from itertools import chain
from pathlib import Path
import hashlib
import shutil
import argparse
from collections import defaultdict
from typing import Optional


def md5(fname: str | Path) -> str:
    """
    Generate an md5 hash for a file

    Args:
        fname: A string or Path instance
    Returns:
        The md5 hash as a string
    """
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as file_pt:
        for chunk in iter(lambda: file_pt.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def select_delete(files: list[Path]) -> None:
    """
    Delete one of the files based on interactive user selection

    Args:
        files: A list of Paths
    """
    print("----")
    options = [f"[{idx+1}] {fn}" for idx, fn in enumerate(files)]
    print("[0] DO NOTHING")
    print("\n".join(options))
    idx = input("SELECT A FILE TO DELETE: ")
    if idx == 0 or not idx:
        print("DOING NOTHING")
        return
    elif 1 <= int(idx) <= len(files):
        delfn = files[int(idx) - 1]
        delfn.unlink()
        print(f"DELETING: {delfn}")


def find(path: Path, dodel: bool, csv_path: Optional[Path]):
    """
    Find duplicated files and potentially delete them

    Duplicate files must have both the same base name and size

    Args:
        path: A Path to a directory
        dodel: Provide deletion dialogue, otherwise just output to console
        csv_path: Store the output to a CSV file at this location
    """
    # Group files (same basename/size) by md5 hash
    md5sums = defaultdict(list)

    # Get all files
    all_files = list(path.rglob("*"))
    for idx, filename in enumerate(all_files):
        print(
            f"{(idx+1)/len(all_files)*100:5.1f}% ({idx+1}/{len(all_files)})\r", end=""
        )
        if filename.is_file():
            md5sums[md5(filename)].append(filename)

    max_dupes = max(len(dupes) for dupes in md5sums.values())
    out_csv = ["md5,keep," + ",".join(f'"delete{idx}"' for idx in range(max_dupes - 1))]
    for md5v, fns in md5sums.items():
        if len(fns) > 1:
            fns.sort(key=lambda fn: len(str(fn)))
            if csv_path:
                out_csv.append(md5v + "," + ",".join(f'"{fn}"' for fn in fns))
            elif dodel:
                select_delete(fns)
            else:
                print("  ".join(map(str, fns)))
    if csv_path:
        csv_path.write_text("\n".join(out_csv))


def delete(csv_path: Path, commit: bool):
    """Delete files named in the CSV

    Args:
        csv_path (Path): The path to the updated CSV
        commit (bool): When true, performs the delete, otherwise previews
    """
    num_dels = 0
    saved = 0
    permission_error = False
    with csv_path.open() as fileptr:
        reader = csv.reader(fileptr)
        next(reader)  # Skip the header row
        for md5v, keep, *deletes in reader:
            keep_copied = False

            assert keep not in deletes, f"{keep} marked for keep AND delete"

            if keep and not Path(keep).is_file():
                assert Path(
                    deletes[0]
                ).is_file(), f"Can't copy {{{keep}}} as named origin can't be found"
                print(
                    "" if commit else "[PREVIEW]",
                    f"Copying {{{deletes[0]}}} to {{{keep}}}",
                )
                if commit:
                    shutil.copy2(deletes[0], keep)
                num_dels -= 1
                keep_copied = True
                saved -= Path(deletes[0]).stat().st_size

            for filename in chain((keep,), deletes):
                if not filename:
                    continue
                path = Path(filename)
                assert (path.is_file() and md5(path) == md5v) or (
                    filename == keep and keep_copied and not commit
                ), f"MD5 hash mismatch for {filename}"
            print(
                "" if commit else "[PREVIEW]",
                f"Keeping {{{keep}}} |",
                f"Deleting {', '.join(f'{{{delt}}}' for delt in deletes if delt)}",
            )
            num_dels += len(deletes)
            for del_file in deletes:
                path = Path(del_file)
                saved += path.stat().st_size
                if commit:
                    try:
                        path.unlink()
                    except PermissionError:
                        permission_error = True
    print(
        "" if commit else "[PREVIEW]",
        f"Deleted {num_dels} duplicates |",
        f"Saved {saved / 1024**2:.1f}MB",
    )
    if permission_error:
        print("Permission errors occurred: Please check the deletions were successful")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Manage duplicated files within a directory"
    )

    subparsers = parser.add_subparsers(help="Main function", dest="command")

    parser_find = subparsers.add_parser(
        "find",
        help="Find duplicate files",
        description="Finds duplicates and outputs to screen or CSV with "
        "optional delete",
    )
    parser_find.add_argument("path", type=Path)
    parser_find.add_argument(
        "--delete",
        "-d",
        help="Perform the deletion dialogue (default: just print)",
        default=False,
        action="store_true",
    )
    parser_find.add_argument(
        "--csv",
        "-c",
        help="Store dupes to CSV (overrides delete) for the delete function",
        default=None,
        type=Path,
    )

    parser_del = subparsers.add_parser(
        "delete",
        help="Delete files from CSV",
        description="Remove files from the CSV",
    )
    parser_del.add_argument(
        "csv", type=Path, help="The updated CSV generated by the find function"
    )
    parser_del.add_argument(
        "--delete",
        "-d",
        help="Perform the deletion (default: just preview)",
        default=False,
        action="store_true",
    )

    args = parser.parse_args()
    if args.command == "find":
        find(args.path, args.delete, args.csv)
    elif args.command == "delete":
        delete(args.csv, args.delete)
